package net.jplugin.core.das.route.impl.conn.mulqry;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import net.jplugin.common.kits.StringKit;
import net.jplugin.core.das.api.DataSourceFactory;
import net.jplugin.core.das.route.api.DataSourceInfo;
import net.jplugin.core.das.route.api.TablesplitException;
import net.jplugin.core.das.route.impl.conn.EmptyStatement;
import net.jplugin.core.das.route.impl.conn.mulqry.CombinedSqlParser.ParseResult;
import net.jplugin.core.das.route.impl.conn.mulqry.rswrapper.CountStarWrapper;
import net.jplugin.core.das.route.impl.conn.mulqry.rswrapper.WrapperManager;

public class CombinedStatement extends EmptyStatement{
	List<Statement> statementList = new ArrayList();
	ResultSet theResultSet;
	private boolean closed;
	private Connection conn;
	
	public CombinedStatement(Connection c){
		this.conn = c;
	}
	@Override
	public final boolean execute(String sql) throws SQLException {
		if (!sql.trim().startsWith("SELECT "))
			throw new TablesplitException("span table sql only support SELECT ...");
		this.executeQuery(sql);
		return true;
	}

	@Override
	public final ResultSet executeQuery(String sql) throws SQLException {
		if (this.closed) throw new TablesplitException("can't call in a closed statement");
		ParseResult pr = CombinedSqlParser.parse(sql);
		
		//获取resultList
		ResultSetList resutSet = genResultSetList(pr);
		
		//根据count(*)模式返回不同的值
		this.theResultSet =  WrapperManager.INSTANCE.wrap(resutSet);
		return this.theResultSet;
//		
//		if (pr.getMeta().getCountStar()==1){
//			this.theResultSet = new CountStarWrapper(resutSet);
//			return this.theResultSet;
//		}else{
//			this.theResultSet = resutSet;
//			return theResultSet;
//		}
	}
	
	private ResultSetList genResultSetList(ParseResult pr) throws SQLException {
		List<ResultSet> tempList = new ArrayList<ResultSet>();
		try{
			for (DataSourceInfo dsi:pr.getMeta().getDataSourceInfos()){
				Connection conn = DataSourceFactory.getDataSource(dsi.getDsName()).getConnection();
				for (String destTbName:dsi.getDestTbs()){
					Statement stmt = conn.createStatement();
					statementList.add(stmt);
					ResultSet resultSet = stmt.executeQuery(StringKit.repaceFirst(pr.getSql(), pr.getMeta().getSourceTb(), destTbName));
					tempList.add(resultSet);
				}
			}
			ResultSetList ret = new ResultSetList(this,tempList,pr.getMeta().getOrderParam());
			return ret;
		}catch(Exception e){
			//发生异常的情况下，statement 会在本statement关闭的时候关闭，但是resultSet不会，需要处理一下
			for (ResultSet r:tempList){
				try{
					r.close();
				}catch(Exception e1){}
			}
			if (e instanceof RuntimeException) throw (RuntimeException)e;
			else throw new TablesplitException(e.getMessage(),e);
		}
	}

	@Override
	public int executeUpdate(String sql) throws SQLException {
		throw new RuntimeException("not support");
	}

	@Override
	public void close() throws SQLException {
		String message="";
		int errNum = 0;
		for (Statement s:statementList){
			try{
				s.close();
			}catch(Exception e){
				errNum++;
				message = message +" "+e.getMessage();
			}
		}
		//set closed
		this.closed = true;
		//check throw exception
		if (StringKit.isNotNull(errNum+" exception when close,"+message)) 
			throw new TablesplitException(message);
	}


	@Override
	public ResultSet getResultSet() throws SQLException {
		return this.theResultSet;
	}

	@Override
	public int getUpdateCount() throws SQLException {
		return -1;
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		throw new TablesplitException("not support");
	}

	@Override
	public Connection getConnection() throws SQLException {
		return this.conn;
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		throw new TablesplitException("update multi table is not supported");
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		throw new TablesplitException("update multi table is not supported");	}

	@Override
	public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		throw new TablesplitException("update multi table is not supported");	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		throw new TablesplitException("not support");
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		throw new TablesplitException("not support");
	}

	@Override
	public boolean execute(String sql, String[] columnNames) throws SQLException {
		throw new TablesplitException("not support");
	}

	@Override
	public boolean isClosed() throws SQLException {
		return this.closed;
	}

	
	
}
