package net.jplugin.core.das.route.impl.conn.mulqry;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import net.jplugin.common.kits.StringKit;
import net.jplugin.core.das.api.DataSourceFactory;
import net.jplugin.core.das.route.api.DataSourceInfo;
import net.jplugin.core.das.route.api.TablesplitException;
import net.jplugin.core.das.route.impl.conn.EmptyStatement;
import net.jplugin.core.das.route.impl.conn.mulqry.CombinedSqlParser.ParseResult;

public class CombinedStatement extends EmptyStatement{
	List<Statement> statementList = new ArrayList();
	ResultSet theResultSet;
	private boolean closed;
	private Connection conn;
	
	public CombinedStatement(Connection c){
		this.conn = c;
	}
	@Override
	public boolean execute(String sql) throws SQLException {
		if (!sql.trim().startsWith("SELECT "))
			throw new TablesplitException("span table sql only support SELECT ...");
		this.executeQuery(sql);
		return true;
	}

	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		if (this.closed) throw new TablesplitException("can't call in a closed statement");
		
		ParseResult pr = CombinedSqlParser.parse(sql);
		ResultSetList resultSetList = new ResultSetList(this);
		
		genResultSetList(pr, resultSetList);
		
		if (pr.getMeta().getCountStar()==1){
			this.theResultSet = new ResultSetForCount(resultSetList);
			return this.theResultSet;
		}else{
			this.theResultSet = resultSetList;
			return resultSetList;
		}
	}
	private void genResultSetList(ParseResult pr, ResultSetList resultSetList) throws SQLException {
		try{
			for (DataSourceInfo dsi:pr.getMeta().getDataSourceInfos()){
				Connection conn = DataSourceFactory.getDataSource(dsi.getDsName()).getConnection();
				for (String destTbName:dsi.getDestTbs()){
					Statement stmt = conn.createStatement();
					statementList.add(stmt);
					ResultSet resultSet = stmt.executeQuery(StringKit.repaceFirst(pr.getSql(), pr.getMeta().getSourceTb(), destTbName));
					resultSetList.add(resultSet);
				}
			}
			//初始化orderby
			resultSetList.prepareFetch(pr.getMeta().getOrderParam());
		}catch(Exception e){
			//发生异常的情况下，statement 会在本statement关闭的时候关闭，但是resultSet不会，需要处理一下
			for (ResultSet r:resultSetList.getList()){
				try{
					r.close();
				}catch(Exception e1){}
			}
		}
	}

	@Override
	public int executeUpdate(String sql) throws SQLException {
		throw new RuntimeException("not support");
	}

	@Override
	public void close() throws SQLException {
		String message="";
		int errNum = 0;
		for (Statement s:statementList){
			try{
				s.close();
			}catch(Exception e){
				errNum++;
				message = message +" "+e.getMessage();
			}
		}
		//set closed
		this.closed = true;
		//check throw exception
		if (StringKit.isNotNull(errNum+" exception when close,"+message)) 
			throw new TablesplitException(message);
	}


	@Override
	public ResultSet getResultSet() throws SQLException {
		return this.theResultSet;
	}

	@Override
	public int getUpdateCount() throws SQLException {
		return -1;
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		throw new TablesplitException("not support");
	}

	@Override
	public Connection getConnection() throws SQLException {
		return this.conn;
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		throw new TablesplitException("update multi table is not supported");
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		throw new TablesplitException("update multi table is not supported");	}

	@Override
	public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		throw new TablesplitException("update multi table is not supported");	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		throw new TablesplitException("not support");
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		throw new TablesplitException("not support");
	}

	@Override
	public boolean execute(String sql, String[] columnNames) throws SQLException {
		throw new TablesplitException("not support");
	}

	@Override
	public boolean isClosed() throws SQLException {
		return this.closed;
	}

	
	
}
